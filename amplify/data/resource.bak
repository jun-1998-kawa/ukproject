import { a, defineData, type ClientSchema } from "@aws-amplify/backend";// ==========================// Enums// ==========================// Note: current Gen 2 enum builder does not expose `.required()` / `.array()` on EnumType.// To keep type-checks green and stay forward-compatible, use string fields for enum-backed values// and drive labels via master tables below.const TargetValues = ["MEN", "KOTE", "DO", "TSUKI"] as const;const MethodValues = [  "SURIAGE",  "KAESHI",  "NUKI",  "DEBANA",  "HIKI",  "HARAI",  "KATSUGI",  "RENZOKU",] as const;const StanceValues = ["JODAN", "CHUDAN", "NITOU_SHO", "NITOU_GYAKU"] as const;const PositionValues = [  "SENPO",  "JIHO",  "GOSHO",  "CHUKEN",  "SANSHO",  "FUKUSHO",  "TAISHO",] as const;const WinTypeValues = ["IPPON", "NIHON", "HANSOKU", "HANTEI"] as const;const PointJudgementValues = ["REGULAR", "ENCHO", "HANSOKU"] as const;// ==========================// Schema// ==========================const schema = a.schema({  // --- Master data ---  University: a    .model({      name: a.string().required(),      shortName: a.string(),      code: a.string(),      // Relations (inverse)      players: a.hasMany("Player", "universityId"),      homeMatches: a.hasMany("Match", "ourUniversityId"),      opponentMatches: a.hasMany("Match", "opponentUniversityId"),    })    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  Venue: a    .model({      name: a.string().required(),      address: a.string(),      matches: a.hasMany("Match", "venueId"),    })    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  Player: a    .model({      universityId: a.id().required(),      university: a.belongsTo("University", "universityId"),      name: a.string().required(),      grade: a.integer(), // 蟄ｦ蟷ｴ・井ｾ・ 3・・      enrollYear: a.integer(), // 蜈･蟄ｦ蟷ｴ・井ｾ・ 2024・・      dan: a.string(),      preferredStance: a.string(), // from StanceValues      // Inverse relations      ourBouts: a.hasMany("Bout", "ourPlayerId"),      opponentBouts: a.hasMany("Bout", "opponentPlayerId"),      wonBouts: a.hasMany("Bout", "winnerPlayerId"),      scoredPoints: a.hasMany("Point", "scorerPlayerId"),      concededPoints: a.hasMany("Point", "opponentPlayerId"),      awardedExchanges: a.hasMany("Exchange", "awardedToPlayerId"),      actions: a.hasMany("Action", "actorPlayerId"),    })    .secondaryIndexes((idx) => [      idx("universityId").queryField("listPlayersByUniversity"),      idx("name").queryField("listPlayersByName"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  // Label masters (for Japanese + English names)  TargetMaster: a    .model({      code: a.string().required(), // MEN/KOTE/DO/TSUKI      nameJa: a.string().required(),      nameEn: a.string().required(),      order: a.integer(),      active: a.boolean().required().default(true),    })    .identifier(["code"]) // unique by code    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  MethodMaster: a    .model({      code: a.string().required(), // matches Method enum values      nameJa: a.string().required(),      nameEn: a.string().required(),      order: a.integer(),      active: a.boolean().required().default(true),    })    .identifier(["code"]) // unique by code    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  PositionMaster: a    .model({      code: a.string().required(), // matches Position enum values      nameJa: a.string().required(), // 萓・ 蜈磯拠      nameEn: a.string().required(), // 萓・ Senpo      order: a.integer(),      active: a.boolean().required().default(true),    })    .identifier(["code"]) // unique by code    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  TechniqueDictionary: a    .model({      code: a.string().required(), // 萓・ "KAESHI_KOTE"      target: a.string().required(), // from TargetValues      method: a.string().required(), // from MethodValues      nameJa: a.string().required(),      nameEn: a.string().required(),      aliases: a.string().array(), // 陦ｨ險倥ｆ繧・      active: a.boolean().required().default(true),    })    .identifier(["code"]) // code繧偵Θ繝九・繧ｯ繧ｭ繝ｼ縺ｫ    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  // --- Competition containers ---  Match: a    .model({      heldOn: a.date().required(),      tournament: a.string(),      venueId: a.id(),      venue: a.belongsTo("Venue", "venueId"),      ourUniversityId: a.id().required(),      ourUniversity: a.belongsTo("University", "ourUniversityId"),      opponentUniversityId: a.id().required(),      opponentUniversity: a.belongsTo("University", "opponentUniversityId"),      note: a.string(),      // Inverse relations      bouts: a.hasMany("Bout", "matchId"),    })    .secondaryIndexes((idx) => [      idx("heldOn").queryField("listMatchesByDate"),      idx("opponentUniversityId").queryField("listMatchesByOpponent"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  Bout: a    .model({      matchId: a.id().required(),      match: a.belongsTo("Match", "matchId"),      ourPlayerId: a.id().required(),      ourPlayer: a.belongsTo("Player", "ourPlayerId"),      opponentPlayerId: a.id().required(),      opponentPlayer: a.belongsTo("Player", "opponentPlayerId"),      ourPosition: a.string(), // from PositionValues      ourStance: a.string(), // from StanceValues      opponentStance: a.string(),      startAt: a.datetime(),      endAt: a.datetime(),      winnerPlayerId: a.id(),      winnerPlayer: a.belongsTo("Player", "winnerPlayerId"),      winType: a.string(), // from WinTypeValues      // Inverse relations      points: a.hasMany("Point", "boutId"),      exchanges: a.hasMany("Exchange", "boutId"),      actions: a.hasMany("Action", "boutId"),    })    .secondaryIndexes((idx) => [      idx("matchId").queryField("listBoutsByMatch"),      idx("ourPlayerId").queryField("listBoutsByOurPlayer"),      idx("opponentPlayerId").queryField("listBoutsByOpponentPlayer"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  // --- Point-only logging (current operation) ---  Point: a    .model({      boutId: a.id().required(),      bout: a.belongsTo("Bout", "boutId"),      tSec: a.integer().required(), // 隧ｦ蜷亥・逶ｸ蟇ｾ遘・      scorerPlayerId: a.id().required(),      scorer: a.belongsTo("Player", "scorerPlayerId"),      opponentPlayerId: a.id().required(),      opponent: a.belongsTo("Player", "opponentPlayerId"),      // Make target/methods optional to allow foul-only ippon      target: a.string(),      // Make target/methods optional to allow foul-only ippon      target: a.string(),      sequenceLen: a.integer(), // 1=蜊倡匱, 2=莠梧ｮｵ窶ｦ・井ｻｻ諢擾ｼ・      sequenceTargets: a.string().array(), // 萓・ ['KOTE','MEN']・・argetValues・・      isMutual: a.boolean(),      // 譁・ц      position: a.string(), // 蜈磯拠/荳ｭ蝣・螟ｧ蟆・ｦ・・ositionValues 蜀鈴聞菫晄戟・・      scorerStance: a.string(),      opponentStance: a.string(),      judgement: a.string(), // REGULAR/ENCHO/HANSOKU・・ointJudgementValues・・      isDecisive: a.boolean(), // 隧ｦ蜷医ｒ豎ｺ繧√◆荳謇・      // 髮・ｨ域怙驕ｩ蛹悶く繝ｼ・・ethods驟榊・縺ｮ莉｣譖ｿ繧､繝ｳ繝・ャ繧ｯ繧ｹ・・      techniqueKey: a.string(), // 萓・ 'KOTE:KAESHI+SURIAGE'      // 蟆・擂縺ｮ隧ｳ邏ｰ繝ｭ繧ｰ縺ｨ騾｣謳ｺ縺吶ｋ縺溘ａ縺ｮ繝輔ャ繧ｯ      exchangeKey: a.string(), // 蟆・擂縺ｮExchange ID遲・      version: a.integer().required().default(1),      recordedAt: a.datetime().required(),    })    .secondaryIndexes((idx) => [      idx("boutId").sortKeys(["tSec"]).queryField("listPointsByBout"),      idx("scorerPlayerId").sortKeys(["tSec"]).queryField("listPointsByScorer"),      idx("target").sortKeys(["tSec"]).queryField("listPointsByTarget"),      idx("techniqueKey").sortKeys(["tSec"]).queryField("listPointsByTechnique"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  // --- Future: full logging (Exchange/Action) placeholders ---  // These are defined to allow zero-downtime future expansion.  Exchange: a    .model({      boutId: a.id().required(),      bout: a.belongsTo("Bout", "boutId"),      startSec: a.integer().required(),      endSec: a.integer(),      isMutual: a.boolean(),      awardedToPlayerId: a.id(),      awardedTo: a.belongsTo("Player", "awardedToPlayerId"),      sequenceLen: a.integer(),      version: a.integer().required().default(1),      // Inverse relations      actions: a.hasMany("Action", "exchangeId"),    })    .secondaryIndexes((idx) => [      idx("boutId").sortKeys(["startSec"]).queryField("listExchangesByBout"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  Action: a    .model({      exchangeId: a.id(),      exchange: a.belongsTo("Exchange", "exchangeId"),      boutId: a.id().required(),      bout: a.belongsTo("Bout", "boutId"),      actorPlayerId: a.id().required(),      actor: a.belongsTo("Player", "actorPlayerId"),      tSec: a.integer().required(),      step: a.integer(), // 1,2,3窶ｦ      target: a.string().required(),      methods: a.string().array().required(),      role: a.enum(["ATTACK", "COUNTER", "DEFENSE"]),      isPoint: a.boolean(),      version: a.integer().required().default(1),    })    .secondaryIndexes((idx) => [      idx("exchangeId").sortKeys(["step", "tSec"]).queryField("listActionsByExchange"),      idx("actorPlayerId").sortKeys(["tSec"]).queryField("listActionsByActor"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES"]).to(["create", "update", "delete", "read"]),      allow.groups(["ANALYSTS", "VIEWERS"]).to(["read"]),    ]),  // --- Aggregates (batch updater script or future Streams竊鱈ambda) ---  AggregatePlayerTargetDaily: a    .model({      playerId: a.id().required(),      date: a.string().required(), // YYYY-MM-DD (from recordedAt)      target: a.string().required(), // MEN/KOTE/DO/TSUKI      count: a.integer().required().default(0),    })    .identifier(["playerId", "date", "target"]) // upsert by composite key    .secondaryIndexes((idx) => [      idx("playerId").sortKeys(["date"]).queryField("listAggTargetByPlayerDate"),      idx("date").sortKeys(["playerId"]).queryField("listAggTargetByDate"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES", "ANALYSTS"]).to(["create", "update", "read"]),      allow.groups(["VIEWERS"]).to(["read"]),    ]),  AggregatePlayerMethodDaily: a    .model({      playerId: a.id().required(),      date: a.string().required(),      method: a.string().required(), // e.g., SURIAGE/KAESHI      count: a.integer().required().default(0),    })    .identifier(["playerId", "date", "method"])     .secondaryIndexes((idx) => [      idx("playerId").sortKeys(["date"]).queryField("listAggMethodByPlayerDate"),      idx("date").sortKeys(["playerId"]).queryField("listAggMethodByDate"),    ])    .authorization((allow) => [      allow.groups(["ADMINS", "COACHES", "ANALYSTS"]).to(["create", "update", "read"]),      allow.groups(["VIEWERS"]).to(["read"]),    ]),});export type Schema = ClientSchema<typeof schema>;export const data = defineData({  schema,  authorizationModes: {    defaultAuthorizationMode: "userPool",  },});
