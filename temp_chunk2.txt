    const token = await getToken(); if(!token) return
    for(const b of (m.bouts?.items ?? [])){
      await deleteBoutDeep(b as any)
    }
    await fetch(apiUrl,{ method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query: deleteMatchMutation, variables:{ input:{ id: matchId } } }) }).then(r=> r.json()).then(j=> { if(j.errors) throw new Error(JSON.stringify(j.errors)) })
  }

  async function saveBout(b: Bout, s: RowState){
    const token = await getToken(); if(!token) return
    // Replace mode: clear existing points before creating new ones, so edits don't accumulate
    try{
      for(const p of (b.points?.items ?? [])){
        await fetch(apiUrl,{ method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query: deletePointMutation, variables:{ input:{ id: p.id } } }) }).then(r=> r.json()).then(j=> { if(j.errors) throw new Error(JSON.stringify(j.errors)) })
      }
    }catch(e){ /* ignore and continue */ }
    const payloads: any[] = []
    const push = (side:'left'|'right', p:PointInput|null)=>{
      if(!p) return; if(!p.target||p.methods.length===0) return
      const scorerPlayerId = side==='left' ? b.ourPlayerId : b.opponentPlayerId
      const opponentPlayerId = side==='left' ? b.opponentPlayerId : b.ourPlayerId
      payloads.push({ boutId:b.id, tSec:Number(p.tSec)||0, scorerPlayerId, opponentPlayerId, position:b.ourPosition ?? null, scorerStance: side==='left' ? (b.ourStance ?? null) : (b.opponentStance ?? null), opponentStance: side==='left' ? (b.opponentStance ?? null) : (b.ourStance ?? null), judgement:'REGULAR', isDecisive:false, target:p.target, methods:p.methods, techniqueKey: techniqueKey(p.target,p.methods), recordedAt:new Date().toISOString(), version:1 })
    }
    push('left', s.left1); push('left', s.left2); push('right', s.right1); push('right', s.right2)
    const foulToPoint = (penalized:'left'|'right', count:number)=>{ if(count>=2){ const scorerPlayerId = penalized==='left' ? b.opponentPlayerId : b.ourPlayerId; const opponentPlayerId = penalized==='left' ? b.ourPlayerId : b.opponentPlayerId; payloads.push({ boutId:b.id, tSec:0, scorerPlayerId, opponentPlayerId, position:b.ourPosition ?? null, scorerStance:null, opponentStance:null, judgement:'HANSOKU', isDecisive:false, techniqueKey:'HANSOKU', recordedAt:new Date().toISOString(), version:1 }) } }
    foulToPoint('left', s.leftFouls); foulToPoint('right', s.rightFouls)
    for(const input of payloads){ const r= await fetch(apiUrl,{method:'POST', headers:{'Content-Type':'application/json','Authorization':await getToken() as any}, body: JSON.stringify({ query:createPointMutation, variables:{ input } })}); const j:any=await r.json(); if(j.errors) throw new Error(JSON.stringify(j.errors)) }
    // Auto winType (optional): if enabled, compute from inputs
    const leftCount = payloads.filter(p=> p.scorerPlayerId===b.ourPlayerId).length
    const rightCount = payloads.filter(p=> p.scorerPlayerId===b.opponentPlayerId).length
    let winType: string | null = null
    if(autoResult){
      if(payloads.length === 0){
        winType = 'DRAW'
      } else if(leftCount!==rightCount){
        const winnerPoints = Math.max(leftCount, rightCount)
        winType = winnerPoints>=2 ? 'NIHON' : 'IPPON'
      } else {
        // tie
        if(allowEncho) winType = 'ENCHO'
        else if(allowHantei) winType = 'HANTEI'
        else winType = 'DRAW'
      }
      const nextWinner = leftCount>rightCount? b.ourPlayerId : (rightCount>leftCount? b.opponentPlayerId : null)
      // Only update if different from current
      if(winType && (b.winType !== winType || (b as any).winnerPlayerId !== nextWinner)){
        const r= await fetch(apiUrl,{method:'POST', headers:{'Content-Type':'application/json','Authorization':await getToken() as any}, body: JSON.stringify({ query:updateBoutMutation, variables:{ input:{ id:b.id, winType, winnerPlayerId: nextWinner } } })});
        const j:any= await r.json(); if(j.errors) throw new Error(JSON.stringify(j.errors))
      }
    }
  }

  async function setBoutResult(b:Bout){
    const ed = resultEdit[b.id]; if(!ed) return
    const token = await getToken(); if(!token) return
    const winnerPlayerId = ed.winType==='DRAW' ? null : (ed.winner==='our' ? b.ourPlayerId : b.opponentPlayerId)
    const r= await fetch(apiUrl,{method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query:updateBoutMutation, variables:{ input:{ id:b.id, winType: ed.winType, winnerPlayerId } } })});
    const j:any= await r.json(); if(j.errors) throw new Error(JSON.stringify(j.errors))
    await onSaved()
  }

  async function saveRow(b:Bout){
    const s = rows[b.id]; if(!s) return;
    setOpMsg(undefined); setSavingId(b.id)
    try{
      const token = await getToken(); if(!token){ setOpMsg(t('errors.notSignedIn')); return }
      await saveBout(b,s)
      setOpMsg(t('notices.saved'))
      await onSaved()
    }catch(e:any){ setOpMsg(String(e?.message ?? e)) }
    finally{ setSavingId('') }
  }

  async function saveAll(){ for(const b of bouts){ const s = rows[b.id]; if(!s) continue; await saveBout(b,s) } await onSaved() }

  async function addNewBout(){
    if(!newLeft || !newRight){ alert(t('alerts.selectPlayers')); return }
    let useMatchId = matchId
    const token = await getToken(); if(!token) return
    if(!useMatchId){
      if(!heldOn){ alert(t('alerts.enterDate')); return }
      if(!ourUniversityId || !opponentUniversityId){ alert(t('alerts.selectUniversities')); return }
      const input:any = { heldOn, tournament: tournament||null, isOfficial, ourUniversityId, opponentUniversityId }
      const r= await fetch(apiUrl,{method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query:createMatchMutation, variables:{ input } })});
      const j:any = await r.json(); if(j.errors) throw new Error(JSON.stringify(j.errors));
      useMatchId = j.data.createMatch.id; setMatchId(useMatchId)
    }
    const boutInput:any = { matchId: useMatchId, ourPlayerId: newLeft, opponentPlayerId: newRight, ourPosition:null, ourStance:null, opponentStance:null, winType:null }
    const r2= await fetch(apiUrl,{method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query:createBoutMutation, variables:{ input:boutInput } })});
    const j2:any= await r2.json(); if(j2.errors) throw new Error(JSON.stringify(j2.errors));
    const newId = j2.data.createBout.id as string; setFocusBoutId(newId); setNewLeft(''); setNewRight(''); await onSaved()
  }

  function buildPlayerOptionsEx(list: PlayerEx[], unis: University[], filter: string){
    const f = filter.trim().toLowerCase(); const grouped: Record<string, PlayerEx[]> = {}
    for(const p of list){ if(f && !p.name.toLowerCase().includes(f)) continue; const key = p.universityId ?? 'unknown'; (grouped[key]??=[]).push(p) }
    const order = Object.keys(grouped).sort((a,b)=> (a==='unknown'?'ZZZ':a).localeCompare(b==='unknown'?'ZZZ':b))
    const opts:any[]=[]; for(const key of order){ const label = key==='unknown' ? t('labels.universityUnknown') : (unis.find(u=> u.id===key)?.name ?? key); const children = grouped[key].sort((a,b)=> a.name.localeCompare(b.name,'ja')).map(p=> (<option key={p.id} value={p.id}>{p.name}</option>)); opts.push(<optgroup key={key} label={label}>{children}</optgroup>) }
    return opts
  }

  function ipponValidOrEmpty(v: PointInput | null){ if(!v) return true; const empty = (!v.target && v.methods.length===0 && (v.tSec==='' || v.tSec===undefined)); if(empty) return true; const valid = (v.methods.length>0) && !!v.target && ((typeof v.tSec==='number' && v.tSec>=0) || v.tSec===''); return valid }
  function ipponIsValid(v: PointInput | null){ return !!(v && v.methods.length>0 && !!v.target) }
  function rowHasData(s: RowState){
    return ipponIsValid(s.left1) || ipponIsValid(s.left2) || ipponIsValid(s.right1) || ipponIsValid(s.right2) || (s.leftFouls>=2) || (s.rightFouls>=2)
  }

  return (
    <>
    <View>
      <View marginBottom="0.5rem" display="flex" style={{gap:'0.5rem', flexWrap:'wrap', alignItems:'flex-end'}}>
        <SelectField label={t('labels.match')} value={matchId} onChange={e=> setMatchId(e.target.value)} size="small">
          <option value="">{t('placeholders.select')}</option>
          {matches.map(m => (<option key={m.id} value={m.id}>{m.heldOn} {m.tournament ?? ''}</option>))}
        </SelectField>
        <TextField label={t('labels.tournament')} value={tournament} onChange={e=> setTournament(e.target.value)} width={dense?"12rem":"16rem"} />
        <TextField label={t('labels.date')} type="date" value={heldOn} onChange={e=> setHeldOn(e.target.value)} width={dense?"10rem":"12rem"} />
        <label style={{ display:'flex', alignItems:'center', gap:6, fontSize:12 }}>
          <input type="checkbox" checked={isOfficial} onChange={e=> setIsOfficial(e.target.checked)} disabled={!!matchId} /> {isOfficial ? t('labels.official') : t('labels.practice')}
        </label>
        <SelectField label={t('labels.ourUniversity')} value={ourUniversityId} onChange={e=> setOurUniversityId(e.target.value)} size="small" isDisabled={!!matchId}>
          <option value="">{t('placeholders.unselected')}</option>
          {universities.map(u=> (<option key={u.id} value={u.id}>{u.name}</option>))}
        </SelectField>
        <SelectField label={t('labels.opponentUniversity')} value={opponentUniversityId} onChange={e=> setOpponentUniversityId(e.target.value)} size="small" isDisabled={!!matchId}>
          <option value="">{t('placeholders.unselected')}</option>
          {universities.map(u=> (<option key={u.id} value={u.id}>{u.name}</option>))}
        </SelectField>
        <Button size="small" variation="primary" onClick={saveAll} isDisabled={bouts.length===0}>{t('actions.saveAll')}</Button>
        {matchId && (
          <Button size="small" variation="link" colorTheme="warning" onClick={()=> setDelModal({ open:true, kind:'match', targetId: matchId, bout: null })}>{t('actions.deleteMatch')}</Button>
        )}
        <Button size="small" variation="link" onClick={()=> setDense(d=> !d)}>{dense? t('actions.switchStandard'):t('actions.switchDense')}</Button>
      </View>
      <View marginBottom="0.25rem" display="flex" style={{gap:'0.5rem', flexWrap:'wrap', alignItems:'center'}}>
        <TextField label={t('labels.searchPlayer')} placeholder={t('placeholders.nameFilter')} value={playerFilter} onChange={e=> setPlayerFilter(e.target.value)} width={dense?"12rem":"16rem"} />
        <Button size="small" onClick={loadRefData}>{t('actions.reloadRefs')}</Button>
        <div style={{ display:'flex', alignItems:'center', gap:8 }}>
          <label style={{ display:'flex', alignItems:'center', gap:4, fontSize:12 }}>
            <input type="checkbox" checked={allowEncho} onChange={e=> setAllowEncho(e.target.checked)} /> {t('rules.allowEncho')}
          </label>
          <label style={{ display:'flex', alignItems:'center', gap:4, fontSize:12 }}>
            <input type="checkbox" checked={allowHantei} onChange={e=> setAllowHantei(e.target.checked)} /> {t('rules.allowHantei')}
          </label>
          <label style={{ display:'flex', alignItems:'center', gap:4, fontSize:12 }}>
            <input type="checkbox" checked={autoResult} onChange={e=> setAutoResult(e.target.checked)} /> {t('rules.autoResult')}
          </label>
        </div>
      </View>
      {(refError || opMsg) && (
        <div style={{ color: refError? '#b00':'#156a15', fontSize:12, marginBottom:6 }}>
          {refError || opMsg}
        </div>
      )}

      <Table variation="bordered" highlightOnHover style={{ fontSize: dense? 12: 14, lineHeight: dense? 1.15: 1.35 }}>
        <TableHead>
          <TableRow>
            <TableCell as="th" width="16%">{t('columns.leftPlayer')}</TableCell>
            <TableCell as="th" width="16%">A {t('columns.first')}</TableCell>
            <TableCell as="th" width="16%">A {t('columns.second')}</TableCell>
            <TableCell as="th" width="16%">B {t('columns.first')}</TableCell>
            <TableCell as="th" width="16%">B {t('columns.second')}</TableCell>
            <TableCell as="th" width="16%">{t('columns.rightPlayer')}</TableCell>
            <TableCell as="th" width="8%">{t('columns.actions')}</TableCell>
          </TableRow>
          <TableRow>
            <TableCell>
              <select value={newLeft} onChange={e=> setNewLeft(e.target.value)} style={{ width:'100%' }}>
                <option value="">{t('placeholders.selectLeft')}</option>
                {buildPlayerOptionsEx(playersEx, universities, playerFilter)}
              </select>
            </TableCell>
            <TableCell colSpan={3}>
              <div style={{ color:'#666', fontSize:12 }}>{t('hints.addNewMatch')}</div>
            </TableCell>
            <TableCell>
              <select value={newRight} onChange={e=> setNewRight(e.target.value)} style={{ width:'100%' }}>
                <option value="">{t('placeholders.selectRight')}</option>
                {buildPlayerOptionsEx(playersEx, universities, playerFilter)}
              </select>
            </TableCell>
            <TableCell>
              <Button size="small" onClick={addNewBout} isDisabled={!newLeft || !newRight}>{t('actions.add')}</Button>
            </TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {boutsLocal.map((b)=>{
            const s = rows[b.id] ?? { left1:null, left2:null, right1:null, right2:null, leftFouls:0, rightFouls:0 }
            const rowValid = [s.left1, s.left2, s.right1, s.right2].every(ipponValidOrEmpty)
            const hasData = rowHasData(s)
            return (
              <TableRow key={b.id} id={`row-${b.id}`}>
                <TableCell>
                  <div style={{ display:'flex', flexDirection:'column', gap:3 }}>
                    <div style={{ fontWeight: focusBoutId===b.id ? 700 : 600, color: focusBoutId===b.id ? '#156a15' : '#2f4f2f', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>{players[b.ourPlayerId] ?? b.ourPlayerId}</div>
                    <div style={{ display:'flex', alignItems:'center', gap:4 }}>
                      <Button size="small" variation="link" title={t('actions.foulMinus')} onClick={()=> setRows(r=> ({...r, [b.id]: { ...s, leftFouls: Math.max(0, (s.leftFouls||0)-1) }}))} style={{ minWidth:22, padding:'0 4px' }}>-</Button>
                      <Badge variation={s.leftFouls>=2? 'warning':'info'} style={{ padding:'0 6px' }}>{s.leftFouls||0}</Badge>
                      <Button size="small" variation="link" title={t('actions.foulPlus')} onClick={()=> setRows(r=> ({...r, [b.id]: { ...s, leftFouls: Math.min(2, (s.leftFouls||0)+1) }}))} style={{ minWidth:22, padding:'0 4px' }}>+</Button>
                    </div>
                    {s.rightFouls>=2 && (
                      <div><Badge variation="warning" style={{ padding:'0 4px' }}>{t('badges.opponentFoulIppon')}</Badge></div>
                    )}
                  </div>
                </TableCell>
                <TableCell>
                    <IpponCell value={s.left1} onFocus={()=> setFocusBoutId(b.id)} onChange={(next)=> setRows(r=> ({...r, [b.id]: { ...s, left1: next }}))} targets={safeTargets} methods={safeMethods} />
                </TableCell>
                <TableCell>
                    <IpponCell value={s.left2} onFocus={()=> setFocusBoutId(b.id)} onChange={(next)=> setRows(r=> ({...r, [b.id]: { ...s, left2: next }}))} targets={safeTargets} methods={safeMethods} />
                </TableCell>
                <TableCell>
                    <IpponCell value={s.right1} onFocus={()=> setFocusBoutId(b.id)} onChange={(next)=> setRows(r=> ({...r, [b.id]: { ...s, right1: next }}))} targets={safeTargets} methods={safeMethods} />
                </TableCell>
                <TableCell>
                    <IpponCell value={s.right2} onFocus={()=> setFocusBoutId(b.id)} onChange={(next)=> setRows(r=> ({...r, [b.id]: { ...s, right2: next }}))} targets={safeTargets} methods={safeMethods} />
                </TableCell>
                <TableCell>
                  <div style={{ display:'flex', flexDirection:'column', gap:3 }}>
                    <div style={{ fontWeight: focusBoutId===b.id ? 700 : 600, color: focusBoutId===b.id ? '#8a1b1b' : '#4f2f2f', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>{players[b.opponentPlayerId] ?? b.opponentPlayerId}</div>
                    <div style={{ display:'flex', alignItems:'center', gap:4 }}>
                      <Button size="small" variation="link" title={t('actions.foulMinus')} onClick={()=> setRows(r=> ({...r, [b.id]: { ...s, rightFouls: Math.max(0, (s.rightFouls||0)-1) }}))} style={{ minWidth:22, padding:'0 4px' }}>-</Button>
                      <Badge variation={s.rightFouls>=2? 'warning':'info'} style={{ padding:'0 6px' }}>{s.rightFouls||0}</Badge>
                      <Button size="small" variation="link" title={t('actions.foulPlus')} onClick={()=> setRows(r=> ({...r, [b.id]: { ...s, rightFouls: Math.min(2, (s.rightFouls||0)+1) }}))} style={{ minWidth:22, padding:'0 4px' }}>+</Button>
                    </div>
                    {s.leftFouls>=2 && (
                      <div><Badge variation="warning" style={{ padding:'0 4px' }}>{t('badges.foulIppon')}</Badge></div>
                    )}
                  </div>
                </TableCell>
                <TableCell>
                  {!rowValid && (<div style={{ color:'#d17', fontSize:12, marginBottom:4 }}>{t('warnings.incompleteInputs')}</div>)}
                  {rowValid && autoResult && (<div style={{ color:'#666', fontSize:11, marginBottom:4 }}>{t('hints.saveAutoJudgement')}</div>)}
                  <div style={{ display:'flex', gap:6, alignItems:'center' }}>
                  <Button size="small" onClick={()=> saveRow(b)} isDisabled={!rowValid || savingId===b.id} isLoading={savingId===b.id}>{t('actions.save')}</Button>
                  <Button size="small" variation="link" colorTheme="warning" onClick={()=> setDelModal({ open:true, kind:'bout', targetId: b.id, bout: b })}>{t('actions.delete')}</Button>
                    {!autoResult && (
                      <>
                        <select value={(resultEdit[b.id]?.winType)|| (b.winType ?? '')} onChange={(e)=> setResultEdit(x=> ({...x, [b.id]: { winType: e.target.value, winner: (resultEdit[b.id]?.winner ?? (b.winnerPlayerId? (b.winnerPlayerId===b.ourPlayerId?'our':'opponent') : '') ) as any }}))} style={{ fontSize:12 }}>
                          <option value="">-</option>
                          <option value="IPPON">{t('winType.IPPON')}</option>
                          <option value="NIHON">{t('winType.NIHON')}</option>
                          <option value="ENCHO">{t('winType.ENCHO')}</option>
                          <option value="HANTEI">{t('winType.HANTEI')}</option>
                          <option value="HANSOKU">{t('winType.HANSOKU')}</option>
                          <option value="DRAW">{t('winType.DRAW')}</option>
                        </select>
                        {(resultEdit[b.id]?.winType ?? b.winType) !== 'DRAW' && (
                          <select value={(resultEdit[b.id]?.winner) || (b.winnerPlayerId? (b.winnerPlayerId===b.ourPlayerId?'our':'opponent'): '')} onChange={(e)=> setResultEdit(x=> ({...x, [b.id]: { winType: (resultEdit[b.id]?.winType ?? (b.winType || '')) as any, winner: e.target.value as any }}))} style={{ fontSize:12 }}>
