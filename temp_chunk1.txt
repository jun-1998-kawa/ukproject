import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { View, Table, TableHead, TableRow, TableCell, TableBody, Button, SelectField, TextField, Badge } from '@aws-amplify/ui-react'
import { methodAllowedForTargetJaLabel } from '../lib/tech'

type Master = { code: string; nameJa?: string; nameEn?: string }
type Bout = {
  id: string;
  ourPlayerId: string;
  opponentPlayerId: string;
  ourPosition?: string;
  ourStance?: string;
  opponentStance?: string;
  winType?: string | null;
  winnerPlayerId?: string | null;
  points?: { items: { id: string; tSec: number; target?: string|null; methods?: string[]|null; scorerPlayerId?: string|null; judgement?: string|null }[] }
}
type PointInput = { tSec: number | ''; target: string; methods: string[] }
type University = { id: string; name: string; shortName?: string|null }
type PlayerEx = { id: string; name: string; universityId?: string|null }

function IpponCell(props: {
  value: PointInput | null
  onChange: (next: PointInput | null) => void
  targets: Master[]
  methods: Master[]
  onFocus?: () => void
}){
  const { t, i18n } = useTranslation()
  const { value, onChange, targets, methods, onFocus } = props
  const v = value ?? { tSec: 0, target: '', methods: [] }
  const valid = (v.methods.length>0) && !!v.target && ((typeof v.tSec === 'number' && v.tSec >= 0) || v.tSec==='')
  const [open, setOpen] = useState(false)

  function parseTime(input: string): number | '' {
    const s = input.trim()
    if(s === '') return ''
    const mmss = s.match(/^([0-9]{1,2})[:'m]\s*([0-5]?[0-9])$/)
    if(mmss){ return Number(mmss[1])*60 + Number(mmss[2]) }
    const n = Number(s); return Number.isFinite(n) && n>=0 ? n : ''
  }

  function targetLabelJa(code:string){ const m = targets.find(t=> t.code===code); return (m?.nameJa ?? m?.nameEn ?? '') }
  function methodAllowedForTarget2(mcode:string, tcode:string){
    if(!tcode) return true
    const tl = targetLabelJa(tcode)
    // Prefer Japanese label; fall back to common target codes
    if(tl) return methodAllowedForTargetJaLabel(mcode, tl)
    const code = (tcode||'').toUpperCase()
    if(mcode==='GYAKU') return code.includes('DO')
    if(mcode==='HIDARI') return code.includes('KOTE')
    if(mcode==='AIKOTE') return code.includes('MEN')
    return true
  }
  function methodAllowedForTarget(mcode:string, tcode:string){
    if(!tcode) return true
    const tl = targetLabelJa(tcode)
    if(mcode==='GYAKU') return tl.includes('ì∑')
    if(mcode==='HIDARI') return tl.includes('è¨éË')
    if(mcode==='AIKOTE') return tl.includes('ñ ')
    return true
  }

  return (
    <div style={{ position:'relative', display: 'grid', gridTemplateColumns: 'minmax(32px,auto) 1fr', gridAutoRows:'minmax(20px,auto)', gap: 4, border: valid ? '1px solid transparent' : '1px solid #e66', borderRadius:6, padding:'2px 4px' }}>
      <div style={{ display:'flex', alignItems:'center', gap:4, minHeight: 24 }}>
        <Button size="small" variation="link" onClick={()=> { onFocus?.(); setOpen(o=> !o) }} title={open ? t('ipponCell.closeMethods') : t('ipponCell.chooseMethods')} style={{ minWidth:28, padding:'2px 4px' }}>
          {open ? '-' : '+'}
        </Button>
        {!open && (
          <div style={{ display:'flex', gap:2, overflow:'hidden', whiteSpace:'nowrap' }}>
            {v.methods.slice(0,2).map(code=> {
              const found = methods.find(mm=> mm.code===code)
              const label = found ? (i18n.language.startsWith('ja') ? (found.nameJa ?? found.nameEn ?? found.code) : (found.nameEn ?? found.code)) : code
              return (<Badge key={code} variation="info" style={{ padding:'0 4px' }}>{label}</Badge>)
            })}
            {v.methods.length>2 && (<Badge variation="info" style={{ padding:'0 4px' }}>+{v.methods.length-2}</Badge>)}
          </div>
        )}
      </div>
      {open && (
        <div style={{ position:'absolute', top:'100%', left:0, zIndex:20, marginTop:4, background:'#fff', display:'grid', gridTemplateColumns:'repeat(2, 1fr)', gap:4, maxHeight:140, width:260, overflowY:'auto', border:'1px solid #ddd', borderRadius:6, padding:6, boxShadow:'0 2px 8px rgba(0,0,0,0.15)' }}>
          {methods.map(m=> {
            const checked = v.methods.includes(m.code)
            const allowed = methodAllowedForTarget2(m.code, v.target)
            return (
              <label key={m.code} style={{ display:'flex', alignItems:'center', gap:6, fontSize:12, opacity: allowed?1:0.4 }}>
                <input type="checkbox" disabled={!allowed} checked={checked && allowed} onChange={(e)=>{
                  onFocus?.();
                  if(e.target.checked) onChange({ ...v, methods: [...v.methods, m.code] })
                  else onChange({ ...v, methods: v.methods.filter(x=> x!==m.code) })
                }} />
                <span>{i18n.language.startsWith('ja') ? (m.nameJa ?? m.nameEn ?? m.code) : (m.nameEn ?? m.code)}</span>
              </label>
            )
          })}
        </div>
      )}
      <SelectField label={t('labels.target')||'Target'} labelHidden placeholder={t('ipponCell.targetPlaceholder')} value={v.target} onChange={(e)=> { onFocus?.(); const nextTarget=e.target.value; const filtered = (v.methods||[]).filter(m=> methodAllowedForTarget2(m, nextTarget)); onChange({ ...v, target: nextTarget, methods: filtered }) }} size="small">
        <option value=""></option>
        {targets.map(tgt=> (
          <option key={tgt.code} value={tgt.code}>{i18n.language.startsWith('ja') ? (tgt.nameJa ?? tgt.nameEn ?? tgt.code) : (tgt.nameEn ?? tgt.code)}</option>
        ))}
      </SelectField>
      <div style={{ gridColumn:'1 / 2', display:'flex', alignItems:'center', gap:4 }}>
        <TextField label={t('labels.seconds')||'Seconds'} labelHidden placeholder={t('ipponCell.secondsPlaceholder')} value={v.tSec === '' ? '' : String(v.tSec)} onChange={(e)=> { onFocus?.(); onChange({ ...v, tSec: parseTime(e.target.value) }) }} width="40px" style={{ padding:'2px 4px' }} />
        <span style={{ fontSize:10, color:'#666' }}>s</span>
      </div>
    </div>
  )
}

export default function NewEntryMode(props: {
  matchId: string
  setMatchId: (id: string)=> void
  matches: { id: string; heldOn: string; tournament?: string; isOfficial?: boolean; bouts?: { items: Bout[] } }[]
  bouts: Bout[]
  players: Record<string,string>
  masters: { targets: Master[]; methods: Master[] }
  apiUrl: string
  getToken: () => Promise<string | null>
  onSaved: ()=> Promise<void> | void
}){
  const { t } = useTranslation()
  const { matchId, setMatchId, matches, bouts, players, masters, apiUrl, getToken, onSaved } = props
  type RowState = { left1: PointInput | null; left2: PointInput | null; right1: PointInput | null; right2: PointInput | null; leftFouls: number; rightFouls: number }
  const [rows, setRows] = useState<Record<string, RowState>>({})
  const [boutsLocal, setBoutsLocal] = useState<Bout[]>(bouts)
  const [autoResult, setAutoResult] = useState<boolean>(true)
  const [resultEdit, setResultEdit] = useState<Record<string, { winType: string; winner: 'our'|'opponent'|'' }>>({})
  const [tournament, setTournament] = useState<string>('')
  const [heldOn, setHeldOn] = useState<string>('')
  const [newLeft, setNewLeft] = useState<string>('')
  const [newRight, setNewRight] = useState<string>('')
  const [playerFilter, setPlayerFilter] = useState('')
  const [universities, setUniversities] = useState<University[]>([])
  const [playersEx, setPlayersEx] = useState<PlayerEx[]>([])
  const [ourUniversityId, setOurUniversityId] = useState<string>('')
  const [opponentUniversityId, setOpponentUniversityId] = useState<string>('')
  const [isOfficial, setIsOfficial] = useState<boolean>(true)
  const [refError, setRefError] = useState<string|undefined>(undefined)
  const [dense, setDense] = useState<boolean>(true)
  // Fallback masters when API returns empty in prod
  const fallbackTargets: Master[] = [
    { code: 'MEN', nameJa: 'ñ ', nameEn: 'Men' },
    { code: 'KOTE', nameJa: 'è¨éË', nameEn: 'Kote' },
    { code: 'DO', nameJa: 'ì∑', nameEn: 'Do' },
    { code: 'TSUKI', nameJa: 'ìÀÇ´', nameEn: 'Tsuki' },
  ]
  const fallbackMethods: Master[] = [
    { code:'SURIAGE', nameJa:'Ç∑ÇËè„Ç∞', nameEn:'Suriage' },
    { code:'KAESHI', nameJa:'ï‘Çµ', nameEn:'Kaeshi' },
    { code:'NUKI', nameJa:'î≤Ç´', nameEn:'Nuki' },
    { code:'DEBANA', nameJa:'èoÇŒÇ»', nameEn:'Debana' },
    { code:'HIKI', nameJa:'à¯Ç´', nameEn:'Hiki' },
    { code:'HARAI', nameJa:'ï•Ç¢', nameEn:'Harai' },
    { code:'TOBIKOMI', nameJa:'îÚÇ—çûÇ›', nameEn:'Tobikomi' },
    { code:'GYAKU', nameJa:'ãt', nameEn:'Gyaku' },
    { code:'HIDARI', nameJa:'ç∂', nameEn:'Left' },
    { code:'AIKOTE', nameJa:'ëäè¨éË', nameEn:'Aikote' },
  ]
  const safeTargets = (masters.targets && masters.targets.length>0) ? masters.targets : fallbackTargets
  const safeMethods = (masters.methods && masters.methods.length>0) ? masters.methods : fallbackMethods
  const [focusBoutId, setFocusBoutId] = useState<string>('')
  const [allowEncho, setAllowEncho] = useState<boolean>(true)
  const [allowHantei, setAllowHantei] = useState<boolean>(false)
  const [opMsg, setOpMsg] = useState<string|undefined>(undefined)
  const [savingId, setSavingId] = useState<string>('')

  useEffect(()=>{
    const init: Record<string, RowState> = {}
    for(const b of bouts){ init[b.id] = rows[b.id] ?? { left1:null, left2:null, right1:null, right2:null, leftFouls:0, rightFouls:0 } }
    setRows(init)
    const m = matches.find(m=> m.id===matchId)
    if(m){ setTournament(m.tournament ?? ''); setHeldOn(m.heldOn ?? ''); setIsOfficial((m as any).isOfficial ?? true); setOurUniversityId((m as any).ourUniversityId ?? ''); setOpponentUniversityId((m as any).opponentUniversityId ?? '') }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [bouts.map(b=> b.id).join(','), matchId])

  async function loadRefData(){
    setRefError(undefined)
    try{
      const token = await getToken(); if(!token) return
      // universities
      const qU = `query ListUniversities($limit:Int,$nextToken:String){ listUniversities(limit:$limit,nextToken:$nextToken){ items{ id name shortName } nextToken } }`
      let ntU: string | null = null; const accU: University[] = []
      do{ const r = await fetch(apiUrl, { method:'POST', headers:{ 'Content-Type':'application/json','Authorization':token }, body: JSON.stringify({ query: qU, variables:{ limit:200, nextToken: ntU } }) }); const j:any = await r.json(); if(j.errors) throw new Error(JSON.stringify(j.errors)); accU.push(...j.data.listUniversities.items); ntU=j.data.listUniversities.nextToken } while(ntU)
      setUniversities(accU)
      // players with universityId
      const qP = `query ListPlayers($limit:Int,$nextToken:String){ listPlayers(limit:$limit,nextToken:$nextToken){ items{ id name universityId } nextToken } }`
      let ntP: string | null = null; const accP: PlayerEx[] = []
      do{ const r = await fetch(apiUrl, { method:'POST', headers:{ 'Content-Type':'application/json','Authorization':token }, body: JSON.stringify({ query: qP, variables:{ limit:200, nextToken: ntP } }) }); const j:any = await r.json(); if(j.errors) throw new Error(JSON.stringify(j.errors)); accP.push(...j.data.listPlayers.items); ntP=j.data.listPlayers.nextToken } while(ntP)
      setPlayersEx(accP)
    } catch(e:any){ setRefError(t('errors.refDataLoadFailed')) }
  }
  useEffect(()=>{ try{ const saved=localStorage.getItem('ui:dense'); if(saved!=null) setDense(saved==='1') }catch{}; try{ const re=localStorage.getItem('rules:encho'); if(re!=null) setAllowEncho(re==='1') }catch{}; try{ const rh=localStorage.getItem('rules:hantei'); if(rh!=null) setAllowHantei(rh==='1') }catch{}; loadRefData() }, [])
  useEffect(()=>{ try{ const ar=localStorage.getItem('rules:autoResult'); if(ar!=null) setAutoResult(ar==='1') }catch{} },[])
  useEffect(()=>{ try{ localStorage.setItem('ui:dense', dense?'1':'0') }catch{} }, [dense])
  useEffect(()=>{ try{ localStorage.setItem('rules:encho', allowEncho?'1':'0') }catch{} }, [allowEncho])
  useEffect(()=>{ try{ localStorage.setItem('rules:hantei', allowHantei?'1':'0') }catch{} }, [allowHantei])
  useEffect(()=>{ try{ localStorage.setItem('rules:autoResult', autoResult?'1':'0') }catch{} }, [autoResult])
  useEffect(()=>{ if(!focusBoutId) return; setTimeout(()=>{ const el=document.getElementById(`row-${focusBoutId}`); el?.scrollIntoView({behavior:'smooth', block:'center'}) },150) }, [focusBoutId, bouts.length])
  useEffect(()=>{ setBoutsLocal(bouts) }, [bouts])

  // hydrate input rows from existing points so previously-saved techniques are visible
  useEffect(()=>{
    if(!bouts || bouts.length===0) return
    setRows(prev => {
      const next = { ...prev }
      for(const b of bouts){
        const existed = next[b.id]
        if(existed && (existed.left1 || existed.left2 || existed.right1 || existed.right2)) continue
        const pts = (b.points?.items ?? []).filter(p=> p.judgement !== 'HANSOKU')
        const leftPts = pts.filter(p=> p.scorerPlayerId===b.ourPlayerId).sort((a,b)=> (a.tSec||0)-(b.tSec||0)).slice(0,2)
        const rightPts = pts.filter(p=> p.scorerPlayerId===b.opponentPlayerId).sort((a,b)=> (a.tSec||0)-(b.tSec||0)).slice(0,2)
        const map = (p:any): PointInput => ({ tSec: Number(p.tSec)||0, target: p.target || '', methods: (p.methods||[]) })
        next[b.id] = {
          left1: leftPts[0] ? map(leftPts[0]) : null,
          left2: leftPts[1] ? map(leftPts[1]) : null,
          right1: rightPts[0] ? map(rightPts[0]) : null,
          right2: rightPts[1] ? map(rightPts[1]) : null,
          leftFouls: 0,
          rightFouls: 0,
        }
      }
      return next
    })
  }, [bouts])

  function techniqueKey(target: string, methods: string[]) { return `${target}:${[...methods].sort().join('+')}` }

  const createPointMutation = `mutation CreatePoint($input: CreatePointInput!) { createPoint(input:$input) { id } }`
  const createMatchMutation = `mutation CreateMatch($input: CreateMatchInput!) { createMatch(input:$input){ id heldOn tournament isOfficial ourUniversityId opponentUniversityId } }`
  const createBoutMutation = `mutation CreateBout($input: CreateBoutInput!) { createBout(input:$input){ id ourPlayerId opponentPlayerId } }`
  const updateBoutMutation = `mutation UpdateBout($input: UpdateBoutInput!) { updateBout(input:$input){ id winType winnerPlayerId } }`
  const deletePointMutation = `mutation DeletePoint($input: DeletePointInput!) { deletePoint(input:$input){ id } }`
  const deleteBoutMutation = `mutation DeleteBout($input: DeleteBoutInput!) { deleteBout(input:$input){ id } }`
  const deleteMatchMutation = `mutation DeleteMatch($input: DeleteMatchInput!) { deleteMatch(input:$input){ id } }`

  const [delModal, setDelModal] = useState<{ open:boolean; kind:'bout'|'match'; targetId: string; bout?: Bout|null }|null>(null)

  async function deleteBoutDeep(b: Bout){
    const token = await getToken(); if(!token) return
    for(const p of (b.points?.items ?? [])){
      await fetch(apiUrl,{ method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query: deletePointMutation, variables:{ input:{ id: p.id } } }) }).then(r=> r.json()).then(j=> { if(j.errors) throw new Error(JSON.stringify(j.errors)) })
    }
    await fetch(apiUrl,{ method:'POST', headers:{'Content-Type':'application/json','Authorization':token}, body: JSON.stringify({ query: deleteBoutMutation, variables:{ input:{ id: b.id } } }) }).then(r=> r.json()).then(j=> { if(j.errors) throw new Error(JSON.stringify(j.errors)) })
  }

  async function deleteMatchDeep(matchId:string){
    const m = matches.find(x=> x.id===matchId); if(!m) return
